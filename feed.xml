<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="zh" /><updated>2018-08-13T08:27:39+00:00</updated><id>http://localhost:4000/</id><title type="html">WaTe</title><subtitle>朝闻道， 夕死可矣
</subtitle><author><name>Shenglong</name><email>liushenglong@wemarklinks.com</email></author><entry><title type="html">Hash算法</title><link href="http://localhost:4000/2018/08/04/Hash%E7%AE%97%E6%B3%95.html" rel="alternate" type="text/html" title="Hash算法" /><published>2018-08-04T00:00:00+00:00</published><updated>2018-08-04T00:00:00+00:00</updated><id>http://localhost:4000/2018/08/04/Hash%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/2018/08/04/Hash%E7%AE%97%E6%B3%95.html">&lt;h3 id=&quot;散列算法&quot;&gt;散列算法&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;散列算法(Hash Function)&lt;/em&gt; 又称&lt;em&gt;散列函数、哈希算法&lt;/em&gt;, 是一种从任何数据中创建小的数字”指纹”的方法。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;原理&lt;/em&gt; 散列函数把数据压缩成_固定格式_的摘要, 使得数据量变小。该函数将数据打乱混合， 重新创建一个叫做散列值的指纹。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;散列冲突&lt;/em&gt; 又称 “散列碰撞”, 所有散列函数都有如下特性:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果两个散列值是不相同的, 那么这两个散列值的原始数据必定是不同的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个特性是因为散列函数都具有_确定性_。然而如果两个散列值相同，两个数据值却可能不同，这种情况称为”散列碰撞”.&lt;/p&gt;

&lt;p&gt;散列函数必须具有不可逆性。&lt;/p&gt;

&lt;h3 id=&quot;散列算法的常见应用&quot;&gt;散列算法的常见应用&lt;/h3&gt;
&lt;p&gt;散列函数应用场景广泛, 通常都是为某一目的专门设计的;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;加密&lt;/em&gt; &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8&quot;&gt;Wiki 密码散列函数&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;加密散列函数的输入数据通常被称为消息, 输出结果被称为&lt;strong&gt;摘要(digest)&lt;/strong&gt;, 主要保证消息在 传输过程中未被篡改;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;理想的加密散列函数应具备的特性:
    &lt;ul&gt;
      &lt;li&gt;高效性;&lt;/li&gt;
      &lt;li&gt;不可逆;&lt;/li&gt;
      &lt;li&gt;不可能在不改动散列数值的情况下修改消息内容;&lt;/li&gt;
      &lt;li&gt;对于不同的消息, 不能给出相同的散列值;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;保证消息的完整性.&lt;/li&gt;
  &lt;li&gt;散列表.&lt;/li&gt;
  &lt;li&gt;错误检测与矫正&lt;/li&gt;
  &lt;li&gt;语音识别&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/2018/08/04/BKDRHash算法&quot;&gt;BKDRHash算法及解析&lt;/a&gt;&lt;/p&gt;</content><author><name>Shenglong</name><email>liushenglong@wemarklinks.com</email></author><category term="算法" /><category term="Hash" /><summary type="html">散列算法 散列算法(Hash Function) 又称散列函数、哈希算法, 是一种从任何数据中创建小的数字”指纹”的方法。 原理 散列函数把数据压缩成_固定格式_的摘要, 使得数据量变小。该函数将数据打乱混合， 重新创建一个叫做散列值的指纹。 散列冲突 又称 “散列碰撞”, 所有散列函数都有如下特性: 如果两个散列值是不相同的, 那么这两个散列值的原始数据必定是不同的。 这个特性是因为散列函数都具有_确定性_。然而如果两个散列值相同，两个数据值却可能不同，这种情况称为”散列碰撞”. 散列函数必须具有不可逆性。 散列算法的常见应用 散列函数应用场景广泛, 通常都是为某一目的专门设计的; 加密 Wiki 密码散列函数 加密散列函数的输入数据通常被称为消息, 输出结果被称为摘要(digest), 主要保证消息在 传输过程中未被篡改; 理想的加密散列函数应具备的特性: 高效性; 不可逆; 不可能在不改动散列数值的情况下修改消息内容; 对于不同的消息, 不能给出相同的散列值; 保证消息的完整性. 散列表. 错误检测与矫正 语音识别 BKDRHash算法及解析</summary></entry><entry><title type="html">初识Docker</title><link href="http://localhost:4000/2018/08/04/Docker.html" rel="alternate" type="text/html" title="初识Docker" /><published>2018-08-04T00:00:00+00:00</published><updated>2018-08-04T00:00:00+00:00</updated><id>http://localhost:4000/2018/08/04/Docker</id><content type="html" xml:base="http://localhost:4000/2018/08/04/Docker.html"></content><author><name>Shenglong</name><email>liushenglong@wemarklinks.com</email></author><category term="容器技术" /><category term="Docker" /><summary type="html"></summary></entry><entry><title type="html">BKDRHash算法</title><link href="http://localhost:4000/2018/08/04/BKDRHash%E7%AE%97%E6%B3%95.html" rel="alternate" type="text/html" title="BKDRHash算法" /><published>2018-08-04T00:00:00+00:00</published><updated>2018-08-04T00:00:00+00:00</updated><id>http://localhost:4000/2018/08/04/BKDRHash%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/2018/08/04/BKDRHash%E7%AE%97%E6%B3%95.html">&lt;h3 id=&quot;bkdrhash算法&quot;&gt;BKDRHash算法&lt;/h3&gt;
&lt;p&gt;BKDRHash函数是一种字符串哈希算法, 用于处理大规模字符串数据时为每一个字符串分配一个整数ID。&lt;/p&gt;

&lt;p&gt;BKDRHash算法java实现:&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bkdrStrHash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Shenglong</name><email>liushenglong@wemarklinks.com</email></author><category term="算法" /><category term="Hash" /><summary type="html">BKDRHash算法 BKDRHash函数是一种字符串哈希算法, 用于处理大规模字符串数据时为每一个字符串分配一个整数ID。 BKDRHash算法java实现: public static int bkdrStrHash(String str){ char c; int hash = 0, seed = 3, index = 0, len = str.length(); for(; index &amp;lt; len; index++) { c = str.charAt(index); hash += Math.pow(seed, len - index - 1) * c; } return hash; }</summary></entry><entry><title type="html">Mysql Database</title><link href="http://localhost:4000/2018/07/28/Knowledge-Map.html" rel="alternate" type="text/html" title="Mysql Database" /><published>2018-07-28T00:00:00+00:00</published><updated>2018-07-28T00:00:00+00:00</updated><id>http://localhost:4000/2018/07/28/Knowledge-Map</id><content type="html" xml:base="http://localhost:4000/2018/07/28/Knowledge-Map.html">&lt;h5 id=&quot;database&quot;&gt;Database&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Mysql&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Redis&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;H2&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Nginx&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Bind9&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;https://dev.mysql.com/doc/&quot;&gt;Mysql Documentation&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;https://redis.io/commands&quot;&gt;Redis Commands&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;http://www.h2database.com/html/tutorial.html&quot;&gt;H2 Toturial&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;https://nginx.org/en/docs/&quot;&gt;Nginx Cookbook&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;https://www.centos.bz/manual/BIND9-CHS.pdf&quot;&gt;Administrator Reference (Chinese Ver)&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;http://www.mybatis.org/mybatis-3/zh/index.html&quot;&gt;Mybatis3 Documentation&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;go-language&quot;&gt;Go Language&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;ORM&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Go Learing&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;http://doc.gorm.io/database.html&quot;&gt;Guide&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html&quot;&gt;Go Learing&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;github.com/jinzhu/gorm&quot;&gt;Source Code&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;https://jasperxu.github.io/gorm-zh/&quot;&gt;Documentation(Chinese Ver)&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;linux&quot;&gt;Linux&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;https://www.tecmint.com/linux-commands-cheat-sheet/&quot;&gt;Commands&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;log-framework&quot;&gt;Log Framework&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;https://logback.qos.ch/&quot;&gt;Logback Home&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;a href=&quot;https://logback.qos.ch/manual/layouts.html&quot;&gt;Logback Pattern&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>Shenglong</name><email>liushenglong@wemarklinks.com</email></author><category term="Documents" /><category term="Knowledge Map" /><summary type="html">Database Mysql Redis H2 Nginx Bind9 Mysql Documentation Redis Commands H2 Toturial Nginx Cookbook Administrator Reference (Chinese Ver) Mybatis3 Documentation         Go Language ORM Go Learing   Guide Go Learing   Source Code     Documentation(Chinese Ver)     Linux       Commands     Log Framework       Logback Home Logback Pattern  </summary></entry><entry><title type="html">碉堡侠的Netty学习日记</title><link href="http://localhost:4000/2018/07/02/Netty-In-Action.html" rel="alternate" type="text/html" title="碉堡侠的Netty学习日记" /><published>2018-07-02T00:00:00+00:00</published><updated>2018-07-02T00:00:00+00:00</updated><id>http://localhost:4000/2018/07/02/Netty-In-Action</id><content type="html" xml:base="http://localhost:4000/2018/07/02/Netty-In-Action.html"></content><author><name>Shenglong</name><email>liushenglong@wemarklinks.com</email></author><category term="netty" /><summary type="html"></summary></entry><entry><title type="html">命题逻辑</title><link href="http://localhost:4000/2018/06/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61-%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91.html" rel="alternate" type="text/html" title="命题逻辑" /><published>2018-06-12T00:00:00+00:00</published><updated>2018-06-12T00:00:00+00:00</updated><id>http://localhost:4000/2018/06/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61-%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91</id><content type="html" xml:base="http://localhost:4000/2018/06/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61-%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91.html">&lt;h1 id=&quot;命题逻辑&quot;&gt;命题逻辑&lt;/h1&gt;
&lt;h2 id=&quot;命题-命题是一个或真或假-的陈述语句&quot;&gt;命题: 命题是一个&lt;em&gt;或真或假&lt;/em&gt; 的&lt;strong&gt;陈述语句&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;命题:
    &lt;blockquote&gt;
      &lt;p&gt;我饿了&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;不是命题:
    &lt;blockquote&gt;
      &lt;p&gt;我爱北京天安门&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;命题中的可变元素称为变元-用字母表示-如果一个命题是真命题-它的真值为真-用t表示-如果他是假命题其真值为假-用f表示&quot;&gt;命题中的可变元素称为变元, 用字母表示. 如果一个命题是真命题, 它的真值为真, 用T表示; 如果他是假命题,其真值为假, 用F表示;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;: 与或非&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;与 - 合取&lt;/li&gt;
  &lt;li&gt;或 - 析取&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;条件语句&quot;&gt;条件语句&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt; 令&lt;em&gt;p&lt;/em&gt;和&lt;em&gt;q&lt;/em&gt;为命题. 条件语句 &lt;code class=&quot;highlighter-rouge&quot;&gt;p→q&lt;/code&gt; 是命题 &quot;若&lt;em&gt;p&lt;/em&gt;则&lt;em&gt;q&lt;/em&gt;&quot;. 当&lt;em&gt;p&lt;/em&gt;为真而&lt;em&gt;q&lt;/em&gt;为假时, 条件语句 &lt;code class=&quot;highlighter-rouge&quot;&gt;p→q&lt;/code&gt;为假, 否则为真. 其中&lt;em&gt;p&lt;/em&gt;为假设(前项,前提),&lt;em&gt;q&lt;/em&gt;称为结论(或推论); 条件语句也称为&lt;strong&gt;蕴含&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&quot;逆倒置与反&quot;&gt;逆、倒置与反&lt;/h3&gt;
&lt;p&gt;已知条件句 &lt;code class=&quot;highlighter-rouge&quot;&gt;p→q&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;逆蕴含: &lt;code class=&quot;highlighter-rouge&quot;&gt;q→p&lt;/code&gt;
倒置蕴含: &lt;code class=&quot;highlighter-rouge&quot;&gt;非q→非p&lt;/code&gt;
反蕴含: &lt;code class=&quot;highlighter-rouge&quot;&gt;非p-&amp;gt;非q&lt;/code&gt;&lt;/p&gt;
  &lt;h3 id=&quot;逻辑运算符的优先级&quot;&gt;逻辑运算符的优先级&lt;/h3&gt;
  &lt;p&gt;非(!) &amp;gt; 逻辑(&amp;amp;,|) &amp;gt; 条件(→)&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Shenglong</name><email>liushenglong@wemarklinks.com</email></author><category term="离散数学" /><summary type="html">命题逻辑 命题: 命题是一个或真或假 的陈述语句 命题: 我饿了 不是命题: 我爱北京天安门 命题中的可变元素称为变元, 用字母表示. 如果一个命题是真命题, 它的真值为真, 用T表示; 如果他是假命题,其真值为假, 用F表示; 定义: 与或非 与 - 合取 或 - 析取 条件语句 定义 令p和q为命题. 条件语句 p→q 是命题 &quot;若p则q&quot;. 当p为真而q为假时, 条件语句 p→q为假, 否则为真. 其中p为假设(前项,前提),q称为结论(或推论); 条件语句也称为蕴含. 逆、倒置与反 已知条件句 p→q 逆蕴含: q→p 倒置蕴含: 非q→非p 反蕴含: 非p-&amp;gt;非q 逻辑运算符的优先级 非(!) &amp;gt; 逻辑(&amp;amp;,|) &amp;gt; 条件(→)</summary></entry></feed>